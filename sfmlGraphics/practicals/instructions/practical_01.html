<!DOCTYPE html>
<html lang="en">
  <head>
  <title> Practical 1: A quick & dirty introduction to OpenGL</title>
    
    <!-- metadata -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="ENSIMAG Computer Graphics 3D Tutorials.">
    <meta name="author" content="Pierre-Luc Manteaux">
    <meta name="author" content="Thomas Delame">
    
    <!-- 
    #############
    # libraries #
    #############
      bootstrap for style/appearance
      jquery for interactions
      mathjax for mathematic symbols (basically latex in html) 
      highlight for code highlighting -->
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-1.11.2.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
     <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [['\\(', '\\)']]
        }
      });
    </script>
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="./javascript/mathjax_local.js"></script>
    <!-- Highlight package for code highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/idea.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!--
    ####################
    # linked resources #
    #################### -->
    <link href="./css/tutorial.css" rel="stylesheet">
  </head>
  <body data-spy="scroll" data-target="#page-nav" class="tutorial">
    <header> 
      <nav class="navbar navbar-default">
        <div class="container">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-1">
              <span class="sr-only"> Toggle navigation </span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="./index.html">3DCG Practicals</a>
          </div>
          <div class="collapse navbar-collapse" id="navbar-collapse-1">
            <ul class="nav navbar-nav">
              <li>
                <button type="button" data-toggle="dropdown"> Practicals <span class="caret"></span></button>
                <ul class="dropdown-menu">
                    <li><a href="./practical_01.html">Pratical 1 - A quick & dirty introduction to OpenGL</a></li>
                    <li><a href="./practical_02.html">Pratical 2 - 3D primitive modeling</a></li>
                    <li><a href="./practical_03.html">Pratical 3 - Hierarchical modeling </a></li>
                    <li><a href="./practical_04.html">Pratical 4 - Procedural animation </a></li>
                    <li><a href="./practical_05.html">Pratical 5 - Physics-based animation </a></li>
                    <li><a href="./practical_06.html">Pratical 6 - Local illumination </a></li>
                    <li><a href="./practical_07.html">Pratical 7 - Texturing </a></li>
                </ul>
              <li><a href="./project.html"> Project</a></li>
              <li><a href="./../api_doc/index.html"> Documentation </a></li>
            </ul>
          </div>
        </div>
      </nav>
    </header>
    
    <div class="header">
      <div class="container">
        <span class="title"> 3D Computer Graphics Practicals </span>
        <p> 
            Introduction to Computer Graphics with OpenGL 4 and C++
        </p>
      </div>
    </div>   
      
    <div class="container">
      <div class="row">
        <div class="col-md-10" role="main">

        
        <header><h1> Practical 01 - A quick & dirty introduction to OpenGL</h1></header>

        <p>
            This first practical is divided into two parts: tutorials and exercices. 
            Tutorials gradually present the framework used in the practicals while the exercices 
            are about the basic of the graphics library standard, OpenGL.
        </p>

        <p>
            Along the practical we put notes about the graphics pipeline and links to the different API's documentation.
            We strongly advise you to explore these links as often as possible and come back to them as many times as you need.
        </p>

        <p>
            Below, you can find links to different API's documentations that you will certainly use along the tutorials. 
            Don't worry about it right now, you will come back to them later. 
        </p>

        <ul>
            <li> <a href="http://www.cplusplus.com/reference/">Standard C++ Library</a> </li>
            <li> <a href="https://www.opengl.org/sdk/docs/man/">OpenGL4 - SDK reference</a></li>
            <li> <a href="http://glm.g-truc.net/0.9.7/index.html">GLM</a> </li>
            <li> <a href="http://www.sfml-dev.org/documentation/2.3.2/">SFML</a></li>
            <li> <a href="./../api_doc/index.html">Framework API</a> </li>
        </ul>

        <p> Finally, a few words about the color chart: </p> 
            <pre><code class="bash">Bash code</code></pre>
            <pre><code class="cpp">C++ (CPU code)</code></pre>
            <pre><code class="glsl">GLSL (GPU code)</code></pre>
            <button type="button" class="btn btn-warning" data-toggle="collapse" data-target="#testWarning">Warnings</button>
            <div id="testWarning" class="collapse">
                <p>Contains warnings.</p>
            </div>
        
            <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#testInfo">Information</button>
            <div id="testInfo" class="collapse">
                <p>Contains informations.</p>
            </div>
        

          <h2 id="tutorial01" >Tutorial 1: Build and launch the practical framework.</h2>

          <p> 
            Download and extract the source code for this practical <a href="./../resources/practical1.zip">here</a>. 
          </p>

          <p> 
            In case you work on the ENSIMAG computers, <strong>source the script gcc493.sh</strong>. 
            It will load some environment variables to grant you access to a more modern C++ compiler 
            (that is able to deal with the C++11 norm).
          </p>

          <pre><code class="bash">source gcc493.sh</code></pre>

          <p>
            Compile the external libraries as follows: 
          </p>

          <pre><code class="bash">cd extlib/
make</code></pre>

          <p> 
            In order to speed up the compilation, you can specify to the <code class="bash">make</code> 
            command how many threads to use. A good number of thread is typically the number of CPU cores you have, 
            e.g. if you have an 8 core CPU type <code class="bash">make -j8</code>.
          </p>

          <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#aboutExternalLibraries">About the external libraries</button>
          <div id="aboutExternalLibraries" class="collapse">
            <div class="well">
              <p>In this project we use four external libraries:</p>
              <ul>
                  <li><a href="http://glew.sourceforge.net/">GLEW</a>: OpenGL core and extension wrapper that detects which OpenGL extensions are available.</li>
                  <li><a href="http://www.sfml-dev.org/">SFML</a>: Window system.</li>
                  <li><a href="http://glm.g-truc.net/0.9.7/index.html">GLM</a>: Mathematics library for graphics.</li>
                  <li><a href="http://www.freetype.org/">Freetype</a>: Fonts library for text display.</li>
              </ul>
            </div>
          </div>

          <p> 
            Then, go back in the root directory to use the <a href="https://cmake.org/">CMake</a> build system we set for you: 
          </p>

          <pre><code class="bash">mkdir build
cd build
cmake ../
make</code></pre>

          <p>
            These commands create a <em>build/</em> directory that will contain all files created to build the executable. 
            Calling <code class="bash">cmake ../</code> will use the <code class="bash">CMakeLists.txt</code> file 
            at the root directory to setup the build system and automatically generate a Makefile. 
            Whenever you add new source files in the <em>src/</em> or <em>include/</em> directories, 
            you need to call again <code class="bash">cmake ../</code> in the <em>build/</em> directory 
            to use them for building the executable. The executable is named <em>main</em> ; 
            it should be created (by typing <code class="bash">make</code>) and executed in the <em>build/</em> directory.
          </p>

          <p> 
            Now, launch the produced executable: 
          </p>

          <pre><code class="bash">./main</code></pre>

          <p>
            You should get something like this:
          </p>

          <pre><code class="bash">Hello World</code></pre>

          <h2 id="tutorial02" >Tutorial 2: Window and main loop</h2>

          <p>
            Generally, a window does several things:
          </p>

          <ol>
              <li>It initializes an OpenGL context.</li>
              <li>It handles events such as mouse or keyboard events.</li>
              <li>It allows to display on screen what we have drawn in a frame.</li>
          </ol>

          <p>
            In these practicals, the window is wrapped in the <a href="./../api_doc/classViewer.html">Viewer class</a>.
            <br/>
            Let's edit the main function in the file <strong>src/main.cpp</strong>. First, include the header of the Viewer class.
          </p>

          <pre><code class="cpp">#include "./../include/Viewer.hpp"</code></pre>

          <p>
            Then, instanciate a viewer in the main function of your program.
          </p>

          <pre><code class="cpp">int width=1280; //Width of the window (pixel)
int height=720; //Height of the window (pixel)
Viewer viewer(width, height);</code></pre>

          <p>
            Finally, display the window.
          </p>

          <pre><code class="cpp">//Display the window and its associated framebuffer
viewer.display();</code></pre>
          
          <p>
            At this point, if you launch the program, a window should appear and suddenly disappear. 
            The missing ingredient is what is called the <a href="http://gameprogrammingpatterns.com/game-loop.html">main loop</a> of the application. 
            Depending on the application purpose (game, simulation, rendering) the main loop 
            can have different names but it always do the same thing:
          </p>

         <ol>
             <li>it handles events such as mouse and keyboard events.</li>
             <li>it draws content in a frame buffer.</li>
             <li>it displays the content of this frame buffer on the window.</li>
         </ol>

<pre id="main-loop"><code class="cpp">while( viewer.isRunning() )
{
    viewer.handleEvent();
    viewer.draw();
    viewer.display();
}</code></pre>

            <p>
                When you launch the executable, you should now have something like this:
            </p>

            <img src="./images/firstMainLoop.png" class="tutorial-img img-rounded img-responsive" alt="First window" style="max-width: 75%" > <!-- width="75%" height="75%"> -->

            <p>
                Now it's time to draw something in that window.
            </p>

            <h2 id="tutorial03">Tutorial 3: Renderable</h2>

            <p>
                The <a href="./../api_doc/classRenderable.html">Renderable class</a> simply depicts an object 
                that can be added to the Viewer so that it will be drawn on the window. 
                In practice, the Viewer class contains a list of Renderable. 
                When calling the <code class="cpp">Viewer::draw()</code> function, 
                it loops over the list of Renderable and draws each of them.
            </p>

            <p>
                We will instanciate objects to create our scene. These operations could be written inside the following function:
            </p>

<pre><code class="cpp">static void initialize_scene( Viewer&amp; viewer )
{
  //create your renderables and shader programs
  //and add them to the viewer
}
</code></pre>

            <p>
                First, include the following headers in the file src/main.cpp.
            </p>

            <pre><code class="cpp">#include "./../include/ShaderProgram.hpp"
#include "./../include/FrameRenderable.hpp"</code></pre>

            <p>
                Second, instanciate a <a href="./../api_doc/ShaderProgram_8hpp.html">shader program</a> that will be used to draw the Renderable. Add it to the viewer.
            </p>

            <pre><code class="cpp">//Path to the vertex shader glsl code
std::string vShader = "./../shaders/defaultVertex.glsl";
//Path to the fragment shader glsl code
std::string fShader = "./../shaders/defaultFragment.glsl";
//Compile and link the shaders into a program
ShaderProgramPtr defaultShader = std::make_shared&lt;ShaderProgram&gt;(vShader, fShader);
//Add the shader program to the Viewer
viewer.addShaderProgram(defaultShader);</code></pre>

            <p>
                Finally, instanciate a renderable and add it to the viewer.
            </p>

            <pre><code class="cpp">//Shader program instanciation
//...

//When instanciating a renderable, 
//you must specify the shader program used to draw it.
FrameRenderablePtr frame = std::make_shared&lt;FrameRenderable&gt;(defaultShader);
viewer.addRenderable(frame);</code></pre>

            <p>
                When launching the executable you should now get something like this:
            </p>

            <img src="./images/firstRenderable.png" class="tutorial-img img-rounded img-responsive" alt="Frame renderable" style="max-width: 75%">

            <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#aboutSharedPointers">About the shared pointers</button>
            <div id="aboutSharedPointers" class="collapse">
              <div class="well">
                <p> 
                    You may have been confused by the use of shared pointers, <code class="cpp">std::make_shared&lt;&gt;</code>. 
                    Simply put, it is a convenient way to automatically handle the allocation and release 
                    of the memory managed by the pointer. No call to the operators new and delete are needed anymore. 
                    If you want more information, we strongly recommend you to read the 
                    <a href="http://www.cplusplus.com/reference/memory/shared_ptr/"> documentation</a> 
                    as it is now a standard in c++.
                </p>
              </div>
            </div>

            <p>
                Note that you can control the view using the mouse. This is done by a 
                <a href="./../api_doc/classCamera.html">Camera class</a> that updates the view matrix for us.
            </p>

            <h2 id="reminders">Notes about the graphics pipeline</h2>

            <p>
                At this stage of the practical, we will deal with more technicals concepts. 
                <br/>
                We encourage you to take time to read these notes or come back to them later.
            </p>

            <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#transformationPipeline">From a point to the screen: The transformation pipeline</button>
            <div id="transformationPipeline" class="collapse">
              <div class="well">

                <p>
                    Whatever the chosen graphics library, the transformation pipeline is almost always the same when geometry must be rendered to the screen.
                </p>

                <img src="./images/transformationPipeline.png" class="tutorial-img img-rounded img-responsive" alt="OpenGL Transformation pipeline" style="max-width: 75%">

                <ul>
                    <li>
                        <strong>Object coordinates:</strong> Local coordinates of the vertices of an object.
                    </li>
                    <li>
                        <strong>World coordinates:</strong> Local coordinates that have been transformed by the <strong>model matrix</strong>. 
                        The model matrix is a transformation matrix used to place an object in the world. 
                        Thus, an object can be re-used and easily placed at different positions.
                    </li>
                    <li>
                        <strong>Camera coordinates:</strong> World coordinates that have been transformed by the <strong>view matrix</strong>. 
                        The view matrix transforms world coordinates in the viewpoint from where it will be observed. 
                        It is important to keep in mind that the camera is a symbolic object that never moves, 
                        instead it transforms the world coordinates. 
                        This is similar to the <a href="http://futurama.wikia.com/wiki/Dark_matter_engine">Dark matter engine</a> in Futurama: 
                        «The engines don't move the ship at all. The ship stays where it is and the engines move the universe around it.» --Cubert Farnsworth.
                    </li>
                    <li>
                        <strong>Clip coordinates:</strong> Camera coordinates that have been transformed by the <strong>projection matrix</strong>. 
                        The projection matrix defines the viewing volume (frustum), how the vertex data are projected onto the sceen.
                    </li>
                    <li>
                        <strong>Normalized coordinates:</strong> Clip coordinates normalized between \([-1,1]\).
                    </li>
                    <li>
                        <strong>Window coordinates:</strong> Normalized coordinates converted to pixel coordinates.
                    </li>
                </ul>

                <p>For a more detailed description of the transformation pipeline, see <a href="http://www.songho.ca/opengl/gl_transform.html">here</a>.</p>
              </div>
            </div>

            <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#whatIsOpenGL">What is OpenGL ?</button>
            <div id="whatIsOpenGL" class="collapse">
                <div class="well">

                <p>
                    <a href="www.opengl.org/about/">OpenGL</a> is a graphics library standard. 
                    It is the only open, vendor-neutral, multiplatform graphics standard. 
                    Thus, by mastering this standard, you will be able to use it on any Graphics Processing Unit (GPU). 
                    This standard is often mistaken with 
                    <a href="http://www.opengl.org/documentation/implementations/">its implementations</a> (which are libraries).
                </p>

                <p> 
                    One thing to keep in mind: OpenGL is said to be a <em>state machine</em>. 
                    The state is the set of variables on the GPU that are used by the GPU to perform drawing commands. 
                    This state is not set with each drawing commands, thus it allows to send fewer data to the GPU. 
                    This is important as the bus between the GPU and the CPU is quite slow. 
                    Thus, the state has to be modified aside the drawing commands, like global variables. 
                </p>
                
                <p>
                    Keep in mind that two drawing commands issued with the same arguments could lead to different results 
                    if the state had been modified in the meantime. You should then be <strong> very careful to the state</strong>: 
                </p>

                <ul>
                  <li> what parts of the state do you need to modify to obtain the expected results?</li>
                  <li> what is the default values for some parts of the state?</li>
                  <li> what parts of the state need to be restored to its default values to no break later drawing command? </li>
                </ul>

              </div>
            </div>

            <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#graphicsPipeline">OpenGL: The graphics pipeline</button>
            <div id="graphicsPipeline" class="collapse">
              <div class="well">

                <p>
                    Below, we propose a simplified view of the OpenGL graphics pipeline. 
                    Please refer to the <a href="https://www.khronos.org/files/opengl45-quick-reference-card.pdf">OpenGL reference cards</a> 
                    for a detailed description. 
                    <br/>
                    Some steps of the pipeline are programmable by the user through programs called <em> shaders</em>:
                </p>

                <ul>
                    <li>
                        <strong>Vertex shader:</strong> A <strong>vertex</strong> is an object 
                        that will be grouped with others to form primitives. 
                        In OpenGL, you have <a href="https://www.opengl.org/wiki/Primitive">three kinds of primitives</a>: 
                        triangles (3 vertices by primitives), lines (2 vertices by primitives) and points (1 vertex by primtives). 
                        Any other primitives need to be built from these three. A vertex is represented by its <strong>attributes</strong>, 
                        such as its position, color and texture coordinates. The purpose of the vertex shader is to perform computations 
                        on the attributes of <strong>each</strong> vertex, such as world to screen transformation.
                    </li>
                    <li>
                        Tesselation shader: Evaluate if new vertices should be created (optional; in fact, this is two different shaders).
                    </li>
                    <li>
                        Geometry shader: Performs computations on primitive (optional). It can discard a primitive or creates more primitives.
                    </li>
                    <li>
                        <strong>Fragment shader:</strong> Once all the primitives had been defined, 
                        the <strong>rasterization</strong> process takes place. This process discretizes a primitive into <strong>fragments</strong>. 
                        For now, you can think of fragments as the pixel of the screen. 
                        The attribute of the vertices (position, color, ...) are linearly interpolated on the fragment 
                        and are used to compute the final color of the fragment, for instance using a local illumination model. 
                        The fragment shader performs computations on all these fragments, e.g. to compute the local illumination or to texture them.
                    </li>
                    <li>
                        Compute shader: Performs general purpose computations on the GPU (aka GPGPU) as a substitute 
                        to <a href="http://www.nvidia.com/object/cuda_home_new.html">CUDA</a> or 
                        <a href="https://www.khronos.org/opencl/">OpenCL</a>. 
                        This shader is the only step out of the graphics pipeline and is optional.
                    </li>    
                </ul>

                <img src="./images/graphicsPipeline.png" class="tutorial-img img-rounded img-responsive" alt="Simplified OpenGL graphics pipeline">

                <p>
                    In these practicals we will focus on the Vertex shader and the Fragment shader. 
                    In contrast with the other shaders, they do not have a default implementation. 
                    Therefore, they always must be implemented by the user and provide an output 
                    to the next stage of the graphics pipeline.
                </p>

                <ul>
                    <li>The vertex shader should at least provide the position of vertices in the clipped coordinates, <code class="glsl">vec4 gl_Position</code>.</li>
                    <li>The fragment shader should at least provide the color of the fragments resulting from the rasterization stage, a variable with type <code class="glsl">vec4</code></li>
                </ul>

              </div>
            </div>

            <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#whatIsGLSL">What is GLSL ?</button>
            <div id="whatIsGLSL" class="collapse">
              <div class="well">

                <p>
                    Shaders are written in c-like language called GLSL (OpenGL Shading Language). 
                    Each of them define a function <code class="glsl">void main()</code> 
                    that will be called on the GPU to process all vertices in the vertex shader and fragments in the fragment shader. 
                    For now, the more important is to understand the following keywords:
                </p>

                <ul>
                    <li>
                        <code class="glsl">in/out</code>, respectively used to specify input/output variables of the shader. 
                        Please note that if you want to transfer variables from the vertex shader to the fragment shader, 
                        then, the outputs of the vertex shader <strong>must match the names and the types</strong> of the inputs of the fragment shader.
                    </li>
                    <li>
                        <code class="glsl">uniform</code>, used to define global variables that will remain the same 
                        for every vertex and every fragment within the same drawing command. 
                        Such variables are typically constants of an object to render, like its position, orientation.
                    </li>
                </ul>

                <p>
                    And the following built-in variables:
                </p>

                <ul>
                    <li><code class="glsl">vec4 gl_Position</code>, the clip coordinates position of a vertex, that should be set for every vertex in the vertex shader</li>
                </ul>

              </div>
            </div>

          <h2 id="tutorial04" >Tutorial 4: Create your own Renderable</h2>
            
            <h3 id="tutorial04_shaders">Shaders</h3>
            
            <p>
                First of all, you need to prepare the vertex and fragment shaders. 
                <br/>
                In the folder <code class="bash">shaders/</code>, create two files "flatVertex.glsl" and "flatFragment.glsl".
            </p>
            
                <h4>Vertex shader</h4>
                    
                    <p>
                        As mentionned before, the vertex shader is mostly used to place the vertices of a geometry in the clipped space.
                    </p>
                    
                    <pre><code class="glsl">#version 400 //GLSL version, fit with OpenGL version
uniform mat4 projMat, viewMat, modelMat; 
in vec3 vPosition; 
out vec4 color;

void main()
{
    //Transform coordinates from local space to clipped space
    gl_Position = projMat*viewMat*modelMat*vec4(vPosition,1);
    color = vec4(1,0,0,1); //RGBA color defined in [0,1]
}</code></pre>

                <h4>Fragment shader</h4>

                <p>
                    The fragment shader in mainly used to define a color for the fragment of the rasterized primitives. 
                    The following shader is one of the simplest fragment shader: 
                    it only transfers the color of the fragment to the frame buffer. 
                    It is important to keep in mind that this color has been linearly interpolated 
                    from the colors of the primitive vertices at the fragment position.
                </p>

                <pre><code class="glsl">#version 400 //GLSL version, fit with OpenGL version
in vec4 color;
out vec4 fragmentColor;

void main()
{
    fragmentColor = color;
}</code></pre>

                <h4>Shader program</h4>
                
                <p>
                    We just defined what happens in the graphics pipeline. 
                    We now have to focus on the CPU side. 
                    <br/>
                    This starts by compiling and linking your shaders into a shader program. 
                    <br/>
                    This process has been encapsulated in the 
                    <a href="./../api_doc/classShaderProgram.html">ShaderProgram class</a>.
                </p>

<pre><code class="cpp">//Viewer instanciation
//...
            
//Default shader instanciation
//...

//Compile and link the flat shaders into a shader program
vShader = "./../shaders/flatVertex.glsl";
fShader = "./../shaders/flatFragment.glsl";
ShaderProgramPtr flatShader = std::make_shared&lt;ShaderProgram&gt;(vShader, fShader);

//Add the shader to the Viewer
viewer.addShaderProgram(flatShader);

//Renderable instanciation
//...</code></pre>

            <h3 id="tutorial04_create3Dmodel">Create a 3D model</h3>

            <p>
                The 3D model is created inside a renderable object. 
                For this tutorial, the files CubeRenderable.hpp and CubeRenderable.cpp have been prepared 
                and will progressively be filled. First, let's prepare the file main.cpp 
                so that the viewer render an instance of CubeRenderable.
            </p>

<pre><code class="cpp">//Don't forget the include
#include "./../include/CubeRenderable.hpp" 
//...

static void initialize_scene( Viewer&amp; viewer )
{
   //...  
  
  //Instanciate a CubeRenderable while specifying its shader program
  CubeRenderablePtr cube = std::make_shared&lt;CubeRenderable&gt;(flatShader);

  //Add the renderable to the Viewer
  viewer.addRenderable(cube);
}
</code></pre>

            <p>The <code class="cpp">CubeRenderable</code> class contains two members:</p>

            <ul>
                <li><em>m_positions</em>: the vector of vertex positions that describe the object, on the CPU.</li>
                <li><em>m_vBuffer</em>: The identifier of the vexter position buffer on the GPU that stores the positions.</li>
            </ul>

            <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#aboutVector">About vector of positions.</button>
            <div id="aboutVector" class="collapse">
                <div class="well">

                    <p>
                        As mentionned above, positions are stored as a vector of 3D positions. 
                        A vector is c++ collection from the standard library, you can find further details 
                        <a href="http://www.cplusplus.com/reference/vector/vector/">here</a>. 
                        Positions are represented as an array of three float values. 
                        Many libraries exist to manipulate this very basic data structure. 
                        In the practicals, we chose to use the <a href="http://glm.g-truc.net/0.9.7/index.html">GLM library</a>.
                    </p>

                </div>
            </div>

            <p>
                The class also contains two inherited members from the <code class="cpp">Renderable</code> abstract class.
            </p>

            <ul>
                <li><em>m_shaderProgram</em>: A smart pointer to the shader program used to render the Renderable.</li>
                <li><em>m_model</em>: A model matrix to place the object in world space.</li>
            </ul>

            <p>
                The first thing to do is to define a 3D geometry and a default world transformation. 
                This is done in the constructor of <code class="cpp">CubeRenderable</code>:
            </p>

            <pre><code class="cpp">CubeRenderable::CubeRenderable(ShaderProgramPtr shaderProgram) 
  : Renderable(shaderProgram)
{
    //Build the geometry: just a simple triangle for now
    m_positions.push_back( glm::vec3(-1,0,0) );
    m_positions.push_back( glm::vec3(1,0,0) );
    m_positions.push_back( glm::vec3(0,1,0) );

    //Set the model matrix to identity
    m_model = glm::mat4(1.0);
}
</code></pre>

            <p>
                A common beginner mistake is to recompute the object geometry at every frame 
                (for example, in the <code class="cpp">do_draw()</code> function). 
                As this geometry does not change, there is no need to recompute it. 
                Thus, computing only one time in the constructor is the right way to do it. 
            </p>

            <p>
                Then, the geometry is sent to the GPU in an allocated memory stamp that is called <strong>buffer</strong>. 
                As in classic CPU programmation, the buffer is first declared, then memory is allocated and data are assigned to it.
            </p>

          <button type="button" class="btn btn-warning" data-toggle="collapse" data-target="#glcheck">Check your GL commands</button>
          <div id="glcheck" class="collapse">
            <div class="well">

            <p>
                OpenGL commands all start with the <code>gl</code> prefix. 
                Such commands can fail, because the state is incoherent with what you are trying to do or because you sent wrong parameters. 
                These errors are silent: no exception is thrown, no log entry is displayed. 
                Thus, debugging an OpenGL program can quickly become a hassle. 
                In order to ease the debugging process, we provide a c++ macro <code class="cpp">glcheck( ... )</code> 
                (look at the <a href="./../api_doc/gl__helper_8hpp.html">documentation</a>). 
                Be sure to use this macro for <strong>ALL</strong> your OpenGL command. 
                If you are concerned about the runtime overhead such a macro would cause, 
                be assured, the macro does nothing when the code is compiled in release mode.
            </p>
              
             <p>In these instructions, we will omit <code class="cpp">glcheck(...)</code>, in order to improve the readability.</p>
              
            </div>
          </div>

<pre><code class="cpp">//Still in the constructor. Following previous code.

//Create a new buffer identifier
//This is the "name" of a pointer variable on the GPU)
glGenBuffers(1, &m_vBuffer);
//Bind the buffer to the GL_ARRAY_BUFFER binding point
//This is a place to perform vertex attributes operations)
glBindBuffer(GL_ARRAY_BUFFER, m_vBuffer);
//Transfer data to our new buffer thanks to this binding point
//This function resize the buffer to the requested side
glBufferData(GL_ARRAY_BUFFER, m_positions.size()*sizeof(glm::vec3), m_positions.data(), GL_STATIC_DRAW);
</code></pre>

        <p>
            Finally, never forget to release the buffer in the destructor.
        </p>

<pre><code class="cpp">CubeRenderable::~CubeRenderable()
{
    glDeleteBuffers(1, &m_vBuffer);
}
</code></pre>

            <p>
                At this point, <code class="cpp">CubeRenderable</code> creates the geometry of a triangle 
                and sends it to the GPU. However, there is no drawing command yet to render 
                this geometry using a shader program. This is done in the inherited function 
                <code class="cpp">do_draw()</code> of the <a href="./../api_doc/classRenderable.html">Renderable</a> class.
            </p>

            <p>
                In this function, all the inputs of the shader program have to be set. 
                For that purpose, the internal format of the GPU vertex attribute buffers are specified 
                and explicitely linked to the GLSL code of the shaders. 
                Once this is done, the drawing command can be issued. 
                Looking at the GLSL code of the so-called <em>flatShader</em>, the inputs are:
            </p>

            <ul>
                <li><em>projMat</em>: The projection matrix. This is handled by the Viewer's camera.</li>
                <li><em>viewMat</em>: The view matrix. This is handled by the Viewer's camera.</li>
                <li><em>modelMat</em>: The model matrix. We need to sent it to the GPU and link it.</li>
                <li><em>vPosition</em>: The vertex position. We need to link it.</li>
            </ul>

<pre><code class="cpp">CubeRenderable::do_draw()
{
    //Get the identifier (location) of the uniform modelMat in the shader program
    int modelLocation = m_shaderProgram->getUniformLocation("modelMat");
    //Send the data corresponding to this identifier on the GPU
    glUniformMatrix4fv(modelLocation, 1, GL_FALSE, glm::value_ptr(m_model));

    //Get the identifier of the attribute vPosition in the shader program
    int positionLocation = m_shaderProgram->getAttributeLocation("vPosition");
    //Activate the attribute array at this location
    glEnableVertexAttribArray(positionLocation);
    //Bind the position buffer on the GL_ARRAY_BUFFER target
    glBindBuffer(GL_ARRAY_BUFFER, m_vBuffer);
    //Specify the location and the format of the vertex position attribute
    glVertexAttribPointer(positionLocation, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);

    //Draw the triangles
    glDrawArrays(GL_TRIANGLES,0, m_positions.size());

    //Release the vertex attribute array
    glDisableVertexAttribArray(positionLocation);
}
</code></pre>

            <p>
                When launching the executable, you should get something like this:
            </p>

            <img src="./images/firstTriangle.png" class="tutorial-img img-rounded img-responsive" alt="First triangle" style="max-width: 75%">

            <!--Todo: -->
          <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#openGLSummary">Quick summary of OpenGL calls in a Renderable</button>
          <div id="openGLSummary" class="collapse">

            <p>
                Initialization - Constructor
            </p>

              <pre><code class="cpp">//Create buffers on the GPU and returns its ID
//The ID is similar to a pointer name in CPU code
glGenBuffers(...);

//Activate a buffer: Next operations will occur on this buffer
//Specify that data on the buffer are attributes of vertex
glBindBuffer(GL_ARRAY_BUFFER, ...);

//Allocate the buffer memory and transfer data from CPU to GPU
glBufferData(GL_ARRAY_BUFFER, ...);</code></pre>

               <p>
                Runtime - do_draw()
               </p>

<pre><code class="cpp">//Enable
//Activate the attribute array at this location
glEnableVertexAttribArray(...);

//Activate a buffer: Next operations will occur on this buffer
//Specify that data on the buffer are attributes of vertex
glBindBuffer(GL_ARRAY_BUFFER, ...);

//Specify the location and the format of the vertex attribute
glVertexAttribPointer(...);

//Draw openGL primitives
glDrawArrays(GL_TRIANGLES,...);

//Release the vertex attribute array
glDisableVertexAttribArray(...);
</code></pre>
                <p>
                    Destruction - Destructor
                </p>

<pre><code class="cpp">//Delete the buffers
glDeleteBuffers(...);</code></pre>
          </div>

            <h2 id="ex01_new_vertex_attribute">Exercice 1: Adding new vertex attributes</h2>

            <ol>
                <li>Modify flatVertex.glsl so that it also takes color as vertex attribute.</li>
                <li>In CubeRenderable, add a list of colors for the vertices.</li>
                <li>In CubeRenderable, send the colors to the GPU and link them with the shaders.</li>
            </ol>

            <h2 id="ex02_without_indexing">Exercice 2: Geometry without indexing</h2>

            <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#indexing">What is indexing ?</button>
            <div id="indexing" class="collapse">
              <div class="well">

            <img src="./images/indexing.png" class="tutorial-img img-rounded img-responsive" alt="Indexing triangles" style="max-width: 75%">

            <p>
                Geometric primitives, i.e. points, lines, and triangles, are represented using positions. 
                Very often, some adjacent primitives have vertices that share a common 3D position. 
                In such a case, it would be helpful to share the same vertex between the different primitives 
                instead of duplicating that vertex. This is achieved by indexing: the index of a vertex 
                (its order of appearance in vertex buffers) is used to describe primitives. 
                Then, for every primitives using a particular index, the vertex attributes (position, color, normal, ...) 
                of the vertex at that index are re-used.
            </p>
            
            <p>
                In OpenGL, indexing only means adding a new buffer that will contain the vertex indices 
                to use to build the primitives we want to render. This buffer will be bind on the 
                <code class="cpp">GL_ELEMENT_ARRAY_BUFFER</code> target. 
                This drawing command is changed to a version that will use the index buffer. 
                See the code below for implementation detail:
            </p>

            <p>
                Initialization - Constructor
            </p>

<pre><code class="cpp">//For position, color and index
glGenBuffers(...);

//For position and color buffer
glBindBuffer(GL_ARRAY_BUFFER, ...);
glBufferData(GL_ARRAY_BUFFER, ...);

//For index buffer
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ...);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, ...);
</code></pre>

            <p>
                Runtime - do_draw()
            </p>

<pre><code class="cpp">//For position and color 
glEnableVertexAttribArray(...);
glBindBuffer(GL_ARRAY_BUFFER, ...);
glVertexAttribPointer(...);

//For index
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,...);

//Draw openGL primitives
glDrawElements(GL_TRIANGLES,...);

//For position and color
glDisableVertexAttribArray(...);
</code></pre>

            <p>
                Destruction - Destructor
            </p>

<pre><code class="cpp">//For position, color and index
glDeleteBuffers(...);</code></pre>
            </div>
        </div>

            <ol>
                <li>In CubeRenderable, create the geometry of a cube without indexing.</li>
                <li>Assign one color to each triangle that compose the cube.</li>
                <li>How many triangles do you need? How many vertices?</li>
            </ol>

            <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#cubeResult">Expected result</button>
            <div id="cubeResult" class="collapse">
                <img src="./images/firstCube.png" class="tutorial-img img-rounded img-responsive" alt="First Cube" style="max-width: 75%">
            </div>

            <h2 id="exo03_with_indexing">Exercice 3: Geometry with indexing</h2>

            <p>
                Copy CubeRenderable in a new renderable called IndexedCubeRenderable and modify it so that it uses indexing.
            </p>

            <ol>
                <li>Modify the list of positions and create a list of indices</li>
                <li>Use only one color per vertex</li>
                <li>Send the indices to the GPU and link them with the shaders</li>
                <li>How many triangles do you need ? How many vertices ?</li>
            </ol>

            <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#indexingResult">Expected result</button>
            <div id="indexingResult" class="collapse">
                <img src="./images/firstIndexing.png" class="tutorial-img img-rounded img-responsive" alt="Indexing triangle result" style="max-width: 75%">
            </div>

            <h2 id="exo04_transformation">Exercice 4: Basic transformation</h2>

            <ol>
                <li>In main.cpp, instanciate a CubeRenderable and an IndexedCubeRenderable.</li>
                <li>Use the following functions to position the cubes next to each other in the scene.
                    <ul>
                        <li>
                            <a href="./../api_doc/classRenderable.html">Renderable::setModel()</a> 
                        </li>
                        <li>
                            <a href="http://glm.g-truc.net/0.9.2/api/">glm::translate()</a> 
                        </li>
                    </ul>
                </li>

                <li>Use the following functions to deform one of the cube and rotate the other one.
                    <ul>
                        <li>
                            <a href="http://glm.g-truc.net/0.9.2/api/">glm::rotate()</a> 
                        </li>
                        <li>
                            <a href="http://glm.g-truc.net/0.9.2/api/">glm::scale()</a> 
                        </li>
                    </ul>
                </li>
            </ol>
            <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#transformationResult">Expected result after translation</button>
                <div id="transformationResult" class="collapse">
                    <img src="./images/firstTransformation.png" class="tutorial-img img-rounded img-responsive" alt="Basic transformation result" style="max-width: 75%">
                </div>
        </div>
      
        <div class="col-md-2 scrollspy" role="complementary" id="page-nav">
          <nav class="hidden-xs hidden-sm hidden-print" data-spy="affix">
            <ul class="nav">
              <li>
                <a href="#tutorial01">Tutorial 01: introduction</a>
              </li>
              <li>
                <a href="#tutorial02">Tutorial 02: Window and main loop</a>
              </li>
              <li>
                <a href="#tutorial03">Tutorial 03: Renderable</a>
              </li>
              <li>
              <a href="#reminders">Notes about the graphics pipeline</a>
              </li> 
              <li>
                <a href="#tutorial04">Tutorial 04: Create your own Renderable</a>
                <ul class="nav">
                  <li> <a href="#tutorial04_shaders"> &gt; Shaders</a></li>
                  <li> <a href="#tutorial04_create3Dmodel">&gt; Create 3D model</a></li>
                </ul>
              </li>
              <li>
                <a href="#ex01_new_vertex_attribute">Exercice 1: Adding new vertex attributes</a>
              </li>
              <li>
                <a href="#ex02_without_indexing">Exercice 2: Geometry without indexing</a>
              </li>
              <li>
                <a href="#exo03_with_indexing">Exercice 3: Geometry with indexing</a>
              </li>
              <li>
                <a href="#exo04_transformation">Exercice 4: Basic transformation</a>
              </li>
              <li>
                <a class="to-top" href="#top"><span class="glyphicon glyphicon-menu-up"></span>Back to top </a>
              </li>
            </ul>

          </nav>
        </div>
      </div>
    </div>
    <footer>
      <p>
          <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
            <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" />
          </a>
          <span property="dct:title"> CG3D practicals</span> by 
          <span property="cc:attributionName">Pierre-Luc Manteaux</span> and 
          <span property="cc:attributionName">Thomas Delame</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
    </footer>
  </body>
