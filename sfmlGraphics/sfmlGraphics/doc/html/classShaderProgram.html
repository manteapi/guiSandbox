<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Graphique 3D: ShaderProgram Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Graphique 3D
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classShaderProgram-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ShaderProgram Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Assembly of the graphics pipeline programmable steps.  
 <a href="classShaderProgram.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ShaderProgram_8hpp_source.html">ShaderProgram.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:add585b75cb78f4afa865ea7b27c9651e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShaderProgram.html#add585b75cb78f4afa865ea7b27c9651e">ShaderProgram</a> ()</td></tr>
<tr class="memdesc:add585b75cb78f4afa865ea7b27c9651e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a null shader program.  <a href="#add585b75cb78f4afa865ea7b27c9651e">More...</a><br /></td></tr>
<tr class="separator:add585b75cb78f4afa865ea7b27c9651e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170d96b836366ed4fac26809f186ce56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShaderProgram.html#a170d96b836366ed4fac26809f186ce56">ShaderProgram</a> (const std::string &amp;vertex_file_path, const std::string &amp;fragment_file_path)</td></tr>
<tr class="memdesc:a170d96b836366ed4fac26809f186ce56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a shader program from specified file names.  <a href="#a170d96b836366ed4fac26809f186ce56">More...</a><br /></td></tr>
<tr class="separator:a170d96b836366ed4fac26809f186ce56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2eadcfc48cc2e2ddb82aba70553a9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShaderProgram.html#a2d2eadcfc48cc2e2ddb82aba70553a9f">~ShaderProgram</a> ()</td></tr>
<tr class="memdesc:a2d2eadcfc48cc2e2ddb82aba70553a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruction.  <a href="#a2d2eadcfc48cc2e2ddb82aba70553a9f">More...</a><br /></td></tr>
<tr class="separator:a2d2eadcfc48cc2e2ddb82aba70553a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2ba7e70028a58d2bf74443253374fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShaderProgram.html#afd2ba7e70028a58d2bf74443253374fa">load</a> (const std::string &amp;vertex_file_path, const std::string &amp;fragment_file_path)</td></tr>
<tr class="memdesc:afd2ba7e70028a58d2bf74443253374fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load new shaders from source files.  <a href="#afd2ba7e70028a58d2bf74443253374fa">More...</a><br /></td></tr>
<tr class="separator:afd2ba7e70028a58d2bf74443253374fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007cebbd8a26ef27ab136452c3774899"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShaderProgram.html#a007cebbd8a26ef27ab136452c3774899">reload</a> ()</td></tr>
<tr class="memdesc:a007cebbd8a26ef27ab136452c3774899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reload the shader sources.  <a href="#a007cebbd8a26ef27ab136452c3774899">More...</a><br /></td></tr>
<tr class="separator:a007cebbd8a26ef27ab136452c3774899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c3e75ddf54504b5e9f53bf85c34736"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShaderProgram.html#ab3c3e75ddf54504b5e9f53bf85c34736">bind</a> ()</td></tr>
<tr class="separator:ab3c3e75ddf54504b5e9f53bf85c34736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f58620a6426bf12a65aa374f6265b96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShaderProgram.html#a4f58620a6426bf12a65aa374f6265b96">getUniformLocation</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a4f58620a6426bf12a65aa374f6265b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the location of an uniform thanks to its name.  <a href="#a4f58620a6426bf12a65aa374f6265b96">More...</a><br /></td></tr>
<tr class="separator:a4f58620a6426bf12a65aa374f6265b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189bf49ca91ae75861fed4ef8c72753b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShaderProgram.html#a189bf49ca91ae75861fed4ef8c72753b">getAttributeLocation</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a189bf49ca91ae75861fed4ef8c72753b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the location of an attribute thanks to its name.  <a href="#a189bf49ca91ae75861fed4ef8c72753b">More...</a><br /></td></tr>
<tr class="separator:a189bf49ca91ae75861fed4ef8c72753b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b6ae259a04719af0eeeb4aac0be217"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShaderProgram.html#a46b6ae259a04719af0eeeb4aac0be217">programId</a> ()</td></tr>
<tr class="memdesc:a46b6ae259a04719af0eeeb4aac0be217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the identifier of this shader program.  <a href="#a46b6ae259a04719af0eeeb4aac0be217">More...</a><br /></td></tr>
<tr class="separator:a46b6ae259a04719af0eeeb4aac0be217"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a67fb2d8013068ee96625c7f47d979923"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShaderProgram.html#a67fb2d8013068ee96625c7f47d979923">unbind</a> ()</td></tr>
<tr class="memdesc:a67fb2d8013068ee96625c7f47d979923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind any shader program.  <a href="#a67fb2d8013068ee96625c7f47d979923">More...</a><br /></td></tr>
<tr class="separator:a67fb2d8013068ee96625c7f47d979923"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8e974f0576fc00d5f86ce292ba8921b7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShaderProgram.html#a8e974f0576fc00d5f86ce292ba8921b7">null_location</a></td></tr>
<tr class="memdesc:a8e974f0576fc00d5f86ce292ba8921b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special value to represent a null location.  <a href="#a8e974f0576fc00d5f86ce292ba8921b7">More...</a><br /></td></tr>
<tr class="separator:a8e974f0576fc00d5f86ce292ba8921b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a45d8be40b24fffbc195f8bb57c5a5195"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShaderProgram.html#a45d8be40b24fffbc195f8bb57c5a5195">resources_introspection</a> ()</td></tr>
<tr class="separator:a45d8be40b24fffbc195f8bb57c5a5195"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a131f977e3396fd633f2c58e9919590a4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShaderProgram.html#a131f977e3396fd633f2c58e9919590a4">m_programId</a></td></tr>
<tr class="separator:a131f977e3396fd633f2c58e9919590a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e3260f6a74a23c0ce43e2b2f535d69"><td class="memItemLeft" align="right" valign="top">std::unordered_map<br class="typebreak" />
&lt; std::string, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShaderProgram.html#a97e3260f6a74a23c0ce43e2b2f535d69">m_uniforms</a></td></tr>
<tr class="separator:a97e3260f6a74a23c0ce43e2b2f535d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0386f31b01d73becea688fb534298336"><td class="memItemLeft" align="right" valign="top">std::unordered_map<br class="typebreak" />
&lt; std::string, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShaderProgram.html#a0386f31b01d73becea688fb534298336">m_attributes</a></td></tr>
<tr class="separator:a0386f31b01d73becea688fb534298336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5d149deaba5b4cd9e925d3860ca078"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShaderProgram.html#a2f5d149deaba5b4cd9e925d3860ca078">m_vertexFilename</a></td></tr>
<tr class="separator:a2f5d149deaba5b4cd9e925d3860ca078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0272796704f94875ef0d09db3d4c82"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShaderProgram.html#aad0272796704f94875ef0d09db3d4c82">m_fragmentFilename</a></td></tr>
<tr class="separator:aad0272796704f94875ef0d09db3d4c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A shader program is the assembly of the graphics pipeline programmable steps. In particular, for our practicals, it will hold the result of the compilation and the linking of the vertex shader step and the fragment shader step.</p>
<p>We decided to keep this class as simple as possible for these practicals. However, we chose to add a nice feature: instrospection. Simply put, this class examines the shader program to find the location of vertex attributes and uniforms. This way, we do not have to ask the GPU what is the location (if found) of a particular variable name (attribute or uniform). Instead, an instance of the shader program will look into its known variables for a match. This results into a faster rendering as we do not have to send our queries at each from to the GPU to know those locations (remember, the bus between the CPU and the GPU is quite slow, better not it efficiently). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="add585b75cb78f4afa865ea7b27c9651e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ShaderProgram::ShaderProgram </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Null shader program constructor. Perfectly valid shader program, but does nothing. </p>

</div>
</div>
<a class="anchor" id="a170d96b836366ed4fac26809f186ce56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ShaderProgram::ShaderProgram </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vertex_file_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fragment_file_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shader program constructor from GLSL shader files. In the context of this course, we consider only the vertex shader and the fragment shader. However, there exist other programmable stage in the pipeline (see www.opengl.org/sdk/docs/man/html/glCreateShader.xhtml).</p>
<p>If the shaders are invalid or describe an invalid program, this is initialized to the null shader program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex_file_path</td><td>Path to the vertex shader file </td></tr>
    <tr><td class="paramname">fragment_file_path</td><td>Path to the fragment shader file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d2eadcfc48cc2e2ddb82aba70553a9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ShaderProgram::~ShaderProgram </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instance destruction. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab3c3e75ddf54504b5e9f53bf85c34736"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShaderProgram::bind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bind this program to the GPU. This is necessary to render objects or to send uniforms/attributes values. </p>

</div>
</div>
<a class="anchor" id="a189bf49ca91ae75861fed4ef8c72753b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ShaderProgram::getAttributeLocation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the location of an attribute (a program input seen in the vertex shader) thanks to its name. We use the locations obtained by an introspection done after the linking stage. As such, we do not request the GPU to answer this request: we have the answer on the CPU, which would be faster. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The attribute name as it appear in the vertex shader source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute location, null_location if there is no attribute with such name in this program </dd></dl>

</div>
</div>
<a class="anchor" id="a4f58620a6426bf12a65aa374f6265b96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ShaderProgram::getUniformLocation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the location of a uniform thanks to its name. We use the locations obtained by an introspection done after the linking stage. As such, we do not request the GPU to answer this request: we have the answer on the CPU, which would be faster. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The uniform name, as it appear in the shader sources (be aware of the naming convention for blocks and arrays, see <a href="https://www.opengl.org/wiki/Program_Introspection#Naming">https://www.opengl.org/wiki/Program_Introspection#Naming</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The uniform location, null_location if there is no uniform with such name in this program </dd></dl>

</div>
</div>
<a class="anchor" id="afd2ba7e70028a58d2bf74443253374fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShaderProgram::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vertex_file_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fragment_file_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load shaders into this shader program. If the shaders are valid (compilation stage) and they describe a valid program (linking stage), this shader program would be valid. Otherwise, this remains unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex_file_path</td><td>Path to the vertex shader file </td></tr>
    <tr><td class="paramname">fragment_file_path</td><td>Path to the fragment shader file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46b6ae259a04719af0eeeb4aac0be217"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ShaderProgram::programId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the identifier of this shader program on the GPU. </p><dl class="section return"><dt>Returns</dt><dd>The program ID. </dd></dl>

</div>
</div>
<a class="anchor" id="a007cebbd8a26ef27ab136452c3774899"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShaderProgram::reload </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reload existing shader sources into this shader program. This is useful if you decide to modify the shader sources while you execute the binary. This way, you can check, improve, debug shaders and see the results immediately on the screen.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classViewer.html#a692ef0144fbf7511caccefd9a37b43b1" title="Reload managed shader programs from its sources. ">Viewer::reloadShaderPrograms()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a45d8be40b24fffbc195f8bb57c5a5195"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ShaderProgram::resources_introspection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a67fb2d8013068ee96625c7f47d979923"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ShaderProgram::unbind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After this call, the next drawing command will not use any shader program for the rendering, unless another shader program is binded. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a0386f31b01d73becea688fb534298336"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::string, int &gt; ShaderProgram::m_attributes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aad0272796704f94875ef0d09db3d4c82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ShaderProgram::m_fragmentFilename</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a131f977e3396fd633f2c58e9919590a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ShaderProgram::m_programId</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a97e3260f6a74a23c0ce43e2b2f535d69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::string, int &gt; ShaderProgram::m_uniforms</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2f5d149deaba5b4cd9e925d3860ca078"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ShaderProgram::m_vertexFilename</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8e974f0576fc00d5f86ce292ba8921b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ShaderProgram::null_location</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sometimes, you can ask for a uniform or an attribute that does not exist in the shader program with <a class="el" href="classShaderProgram.html#a4f58620a6426bf12a65aa374f6265b96" title="Get the location of an uniform thanks to its name. ">getUniformLocation()</a> and <a class="el" href="classShaderProgram.html#a189bf49ca91ae75861fed4ef8c72753b" title="Get the location of an attribute thanks to its name. ">getAttributeLocation()</a>. As the variable does not exist, the location returned by those function should not point to any existing variable. <code>null_location</code> is a special location value that is guaranteed to never point to an existing variable.</p>
<p>When a null location is returned, this is not always an error. Indeed, when a uniform or an attribute is not used in the shader sources (the compiler can be pretty smart), it is optimized out. Thus, there is no valid location for this variable. It is up to you to detect if the returned value is a null_location and to decide what to do (throw an error or continue happily). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/chardon/Depot/ensimag/2A_G3D/practicals/teacherSource/include/<a class="el" href="ShaderProgram_8hpp_source.html">ShaderProgram.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 19 2016 15:55:20 for Graphique 3D by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
